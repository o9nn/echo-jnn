â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                              â•‘
â•‘                    CogPilot.jl - Data Model Specification                    â•‘
â•‘                           Z++ Formal Specification                           â•‘
â•‘                                                                              â•‘
â•‘  This specification formalizes the data layer of the CogPilot.jl system,    â•‘
â•‘  focusing on the fundamental data structures that represent rooted trees,   â•‘
â•‘  B-series genomes, reservoir states, and membrane configurations.           â•‘
â•‘                                                                              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Â§ 1. BASIC TYPES AND CONSTANTS                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”€â”€[ A000081 Sequence Definition ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

The OEIS A000081 sequence is the mathematical foundation of the entire system.
It counts the number of unlabeled rooted trees with n nodes.

A000081 : â„• â†’ â„•
  where
    A000081(1) = 1
    A000081(2) = 1
    A000081(3) = 2
    A000081(4) = 4
    A000081(5) = 9
    A000081(6) = 20
    A000081(7) = 48
    A000081(8) = 115
    A000081(9) = 286
    A000081(10) = 719
    ...
  
  invariant: âˆ€n âˆˆ â„•, n â‰¥ 1 â‡’ A000081(n) > 0
  invariant: âˆ€n âˆˆ â„•, n â‰¥ 2 â‡’ A000081(n) > A000081(n-1)  // Strictly monotonically increasing

â”€â”€[ Node Identifier Type ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

NodeID â‰™ â„•â‚  // Natural numbers starting from 1

â”€â”€[ Order Type ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Order â‰™ â„•â‚  // Tree order (number of nodes), positive natural number

â”€â”€[ Coefficient Type ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Coefficient â‰™ â„  // Real-valued coefficients for B-series

â”€â”€[ Fitness Type ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Fitness â‰™ { f : â„ | 0.0 â‰¤ f â‰¤ 1.0 }  // Normalized fitness in [0,1]


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Â§ 2. ROOTED TREE REPRESENTATION                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”€â”€[ Level Sequence ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

A rooted tree is represented by a level sequence, which is a compact encoding
of the tree structure as a sequence of natural numbers representing the depth
of each node in a breadth-first traversal.

schema LevelSequence
  sequence : seq â„•
  
  where
    // Level sequence must be non-empty
    #sequence â‰¥ 1
    
    // First element is always 0 (root at level 0)
    sequence[1] = 0
    
    // Each level can increase by at most 1 from previous
    âˆ€i : 2..#sequence â€¢ sequence[i] â‰¤ sequence[i-1] + 1
    
    // Valid tree structure (connected)
    âˆ€i : 2..#sequence â€¢ 
      sequence[i] â‰¤ max({sequence[j] | j âˆˆ 1..(i-1)}) + 1
end

Examples:
  â€¢ [0]         â†’ Single node tree (order 1)
  â€¢ [0, 1]      â†’ Root with one child (order 2)
  â€¢ [0, 1, 1]   â†’ Root with two children (order 3)
  â€¢ [0, 1, 2]   â†’ Linear chain of 3 nodes (order 3)

â”€â”€[ Rooted Tree ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

schema RootedTree
  level_sequence : LevelSequence
  order : Order
  symmetry_factor : â„•â‚
  id : NodeID
  
  where
    // Order equals length of level sequence
    order = #level_sequence.sequence
    
    // Symmetry factor divides order! (factorial)
    âˆƒk : â„• â€¢ k Ã— symmetry_factor â‰¤ factorial(order)
    
    // Trees of order n must satisfy A000081 count
    // (This is a global constraint checked at collection level)
    symmetry_factor â‰¥ 1
end

â”€â”€[ Tree Collection ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

For each order n, the number of distinct rooted trees must equal A000081(n).

schema TreeCollection
  trees_by_order : Order â‡¸ seq RootedTree  // Partial function from order to trees
  max_order : Order
  
  where
    // Domain is contiguous from 1 to max_order
    dom trees_by_order = 1..max_order
    
    // For each order, the count must match A000081
    âˆ€o : dom trees_by_order â€¢
      #(trees_by_order(o)) = A000081(o)
    
    // All trees of order o actually have order o
    âˆ€o : dom trees_by_order â€¢
      âˆ€t : trees_by_order(o) â€¢ t.order = o
    
    // No duplicate trees within an order (up to isomorphism)
    âˆ€o : dom trees_by_order â€¢
      âˆ€tâ‚, tâ‚‚ : trees_by_order(o) â€¢ 
        tâ‚ â‰  tâ‚‚ â‡’ tâ‚.level_sequence â‰  tâ‚‚.level_sequence
    
    // Tree IDs are unique across all orders
    âˆ€oâ‚, oâ‚‚ : dom trees_by_order â€¢
      âˆ€tâ‚ : trees_by_order(oâ‚), tâ‚‚ : trees_by_order(oâ‚‚) â€¢
        tâ‚.id = tâ‚‚.id â‡’ tâ‚ = tâ‚‚
end


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Â§ 3. B-SERIES GENOME                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”€â”€[ Tree-Coefficient Mapping ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

The B-series genome maps rooted trees to their coefficients, representing
the "genetic material" of a computational kernel.

schema GenomeMapping
  coefficients : LevelSequence â‡¸ Coefficient
  
  where
    // At least one tree must be mapped
    #(dom coefficients) â‰¥ 1
    
    // All coefficients are finite real numbers
    âˆ€t : dom coefficients â€¢ 
      isFinite(coefficients(t))
end

â”€â”€[ Kernel Genome ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

schema KernelGenome
  mapping : GenomeMapping
  max_order : Order
  diversity : â„â‰¥0  // Non-negative diversity measure
  
  where
    // All mapped trees have order â‰¤ max_order
    âˆ€t : dom mapping.coefficients â€¢
      #(t.sequence) â‰¤ max_order
    
    // Diversity is standard deviation of coefficients
    let coeff_vals = ran mapping.coefficients in
      #coeff_vals > 0 â‡’
        diversity = sqrt(
          (Î£{c : coeff_vals â€¢ (c - mean(coeff_vals))Â²}) / #coeff_vals
        )
    
    // Zero diversity only if all coefficients equal or empty
    diversity = 0 â‡” 
      (#(ran mapping.coefficients) â‰¤ 1 âˆ¨
       âˆ€câ‚, câ‚‚ : ran mapping.coefficients â€¢ câ‚ = câ‚‚)
end

â”€â”€[ B-Series Expression ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

The B-series expansion for numerical integration:
  y_{n+1} = y_n + h Î£_{Ï„âˆˆT} b(Ï„)/Ïƒ(Ï„) Â· F(Ï„)(y_n)

schema BSeriesExpression
  genome : KernelGenome
  trees : TreeCollection
  step_size : â„>0  // Positive step size h
  
  where
    // All trees in genome exist in tree collection
    âˆ€t : dom genome.mapping.coefficients â€¢
      âˆƒo : dom trees.trees_by_order â€¢
        âˆƒÏ„ : trees.trees_by_order(o) â€¢
          Ï„.level_sequence = t
    
    // Step size must be small enough for stability
    step_size < 1.0  // Heuristic stability bound
end


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Â§ 4. RESERVOIR STATE                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”€â”€[ Reservoir Configuration ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

schema ReservoirConfig
  size : â„•â‚  // Number of reservoir nodes
  input_dim : â„•â‚  // Input dimension
  output_dim : â„•â‚  // Output dimension
  spectral_radius : â„  // Spectral radius of weight matrix
  sparsity : Fitness  // Connection sparsity (0 = sparse, 1 = dense)
  
  where
    // Size must be derived from A000081 (cumulative sum)
    âˆƒn : Order â€¢ size = Î£{i : 1..n â€¢ A000081(i)}
    
    // Spectral radius must be < 1 for echo state property
    0 < spectral_radius < 1.0
    
    // Sparsity in valid range
    0.0 â‰¤ sparsity â‰¤ 1.0
    
    // Dimensions must be positive
    input_dim â‰¥ 1 âˆ§ output_dim â‰¥ 1
end

â”€â”€[ Reservoir Weights ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

schema ReservoirWeights
  W_in : Matrix[input_dim Ã— size]      // Input weights
  W_res : Matrix[size Ã— size]          // Reservoir weights (recurrent)
  W_out : Matrix[output_dim Ã— size]    // Output weights (trained)
  config : ReservoirConfig
  
  where
    // Reservoir weight matrix has correct spectral radius
    spectral_radius(W_res) â‰ˆ config.spectral_radius
    
    // Reservoir sparsity constraint
    let density = count_nonzero(W_res) / (size Ã— size) in
      density â‰ˆ config.sparsity
    
    // Input weights bounded
    âˆ€i,j â€¢ |W_in[i,j]| â‰¤ 1.0
    
    // Output weights initially zero (trained later)
    initially: âˆ€i,j â€¢ W_out[i,j] = 0.0
end

â”€â”€[ Reservoir State ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

schema ReservoirState
  state_vector : Vector[size]  // Current reservoir state
  config : ReservoirConfig
  weights : ReservoirWeights
  time_step : â„•  // Current time step
  
  where
    // State vector has correct dimension
    dim(state_vector) = config.size
    
    // State bounded (due to tanh activation)
    âˆ€i : 1..config.size â€¢ |state_vector[i]| â‰¤ 1.0
    
    // Time step is non-negative
    time_step â‰¥ 0
    
    // Echo state property: fading memory
    // (Informally: past inputs have exponentially decaying influence)
end


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Â§ 5. MEMBRANE COMPUTING STRUCTURES                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”€â”€[ Membrane Identifier ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

MembraneID â‰™ â„•â‚  // Unique membrane identifier

â”€â”€[ Multiset ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

A multiset is a collection where elements can appear multiple times.

schema Multiset[X]
  elements : X â‡¸ â„•â‚  // Element to multiplicity mapping
  
  where
    // All multiplicities are positive
    âˆ€x : dom elements â€¢ elements(x) â‰¥ 1
end

â”€â”€[ Symbol Alphabet ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

schema SymbolAlphabet
  symbols : seq String  // Ordered sequence of symbols
  
  where
    // At least one symbol
    #symbols â‰¥ 1
    
    // No duplicate symbols
    âˆ€i, j : 1..#symbols â€¢ i â‰  j â‡’ symbols[i] â‰  symbols[j]
    
    // Symbols are non-empty strings
    âˆ€s : ran symbols â€¢ #s â‰¥ 1
end

â”€â”€[ Membrane Structure ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

schema Membrane
  id : MembraneID
  parent : MembraneID âˆª {null}  // null for root membrane
  children : set MembraneID
  contents : Multiset[String]  // Symbolic multiset
  level : â„•  // Nesting level (0 for root)
  
  where
    // Root membrane has no parent
    parent = null â‡” level = 0
    
    // Non-root membranes have parent
    parent â‰  null â‡’ level â‰¥ 1
    
    // Membrane not its own parent or child
    parent â‰  id
    id âˆ‰ children
    
    // All symbols in contents come from alphabet
    // (Enforced at system level)
end

â”€â”€[ Evolution Rule ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Membrane evolution rules: u â†’ v (in membrane m)

schema EvolutionRule
  membrane_id : MembraneID
  lhs : Multiset[String]  // Left-hand side (consumed)
  rhs : Multiset[String]  // Right-hand side (produced)
  priority : â„•  // Rule priority (higher = applied first)
  
  where
    // Priority is non-negative
    priority â‰¥ 0
    
    // Both sides non-empty (no creation/annihilation from nothing)
    #(dom lhs.elements) â‰¥ 1
    #(dom rhs.elements) â‰¥ 1
end

â”€â”€[ P-System Configuration ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

schema PSystemConfiguration
  membranes : set Membrane
  alphabet : SymbolAlphabet
  rules : seq EvolutionRule
  root_membrane : MembraneID
  
  where
    // At least one membrane (the root)
    #membranes â‰¥ 1
    
    // Root membrane exists
    âˆƒm : membranes â€¢ m.id = root_membrane âˆ§ m.level = 0
    
    // Membrane IDs are unique
    âˆ€mâ‚, mâ‚‚ : membranes â€¢ mâ‚.id = mâ‚‚.id â‡’ mâ‚ = mâ‚‚
    
    // Parent-child relationships are consistent
    âˆ€m : membranes â€¢ m.parent â‰  null â‡’
      âˆƒp : membranes â€¢ p.id = m.parent âˆ§ m.id âˆˆ p.children
    
    // Tree structure: no cycles
    âˆ€m : membranes â€¢ Â¬(m.id âˆˆ reachable_ancestors(m, membranes))
    
    // Number of membranes aligns with A000081
    âˆƒk : Order â€¢ #membranes = A000081(k)
    
    // All rule symbols in alphabet
    âˆ€r : rules â€¢
      (dom r.lhs.elements âˆª dom r.rhs.elements) âŠ† ran alphabet.symbols
end


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Â§ 6. MEMBRANE GARDEN                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”€â”€[ Tree Location ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

schema TreeLocation
  tree_id : NodeID
  membrane_id : MembraneID
  planted_at : â„•  // Generation when planted
  
  where
    planted_at â‰¥ 0
end

â”€â”€[ Tree Fitness ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

schema TreeFitness
  tree_id : NodeID
  fitness : Fitness
  age : â„•  // Age in generations
  
  where
    age â‰¥ 0
    
    // Fitness degrades with excessive age (senescence)
    age > 100 â‡’ fitness < 0.5
end

â”€â”€[ Membrane Garden ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

A garden cultivates trees within membranes, tracking their locations and fitness.

schema MembraneGarden
  trees : TreeCollection
  locations : set TreeLocation
  fitness_map : NodeID â‡¸ TreeFitness
  membranes : PSystemConfiguration
  generation : â„•
  growth_rate : â„>0
  
  where
    // Growth rate must be A000081-derived
    âˆƒn : Order â€¢ growth_rate â‰ˆ A000081(n+1) / A000081(n)
    
    // All located trees exist in tree collection
    âˆ€loc : locations â€¢
      âˆƒo : dom trees.trees_by_order â€¢
        âˆƒt : trees.trees_by_order(o) â€¢ t.id = loc.tree_id
    
    // All located membranes exist
    âˆ€loc : locations â€¢
      âˆƒm : membranes.membranes â€¢ m.id = loc.membrane_id
    
    // Fitness tracked for all located trees
    dom fitness_map = {loc.tree_id | loc âˆˆ locations}
    
    // Generation is non-negative
    generation â‰¥ 0
    
    // Each tree planted in at most one membrane
    âˆ€locâ‚, locâ‚‚ : locations â€¢
      locâ‚.tree_id = locâ‚‚.tree_id â‡’ locâ‚.membrane_id = locâ‚‚.membrane_id
end


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Â§ 7. J-SURFACE REACTOR STATE                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”€â”€[ J-Surface Configuration ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

schema JSurfaceConfig
  dimension : â„•â‚  // State space dimension
  symplectic : ğ”¹  // Whether structure is symplectic
  
  where
    // Symplectic dimension must be even
    symplectic â‡’ dimension mod 2 = 0
    
    // Dimension derived from A000081
    âˆƒn : Order â€¢ dimension = Î£{i : 1..n â€¢ A000081(i)}
end

â”€â”€[ J-Matrix ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

The J-matrix encodes the geometric structure (symplectic or Poisson).

schema JMatrix
  matrix : Matrix[dimension Ã— dimension]
  config : JSurfaceConfig
  
  where
    // For symplectic: J is skew-symmetric and JÂ² = -I
    config.symplectic â‡’
      (matrix = -transpose(matrix) âˆ§
       matrix Ã— matrix = -identity(dimension))
    
    // For Poisson: J is skew-symmetric (Poisson tensor)
    Â¬config.symplectic â‡’
      matrix = -transpose(matrix)
    
    // Non-degeneracy: det(J) â‰  0 for symplectic
    config.symplectic â‡’ det(matrix) â‰  0
end

â”€â”€[ Hamiltonian Function ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

schema Hamiltonian
  dimension : â„•â‚
  energy : Vector[dimension] â†’ â„  // Energy function H(Ïˆ)
  gradient : Vector[dimension] â†’ Vector[dimension]  // âˆ‡H(Ïˆ)
  
  where
    // Energy must be continuous
    âˆ€Ïˆ : Vector[dimension] â€¢ isFinite(energy(Ïˆ))
    
    // Gradient must exist everywhere
    âˆ€Ïˆ : Vector[dimension] â€¢ isDefined(gradient(Ïˆ))
end

â”€â”€[ J-Surface State ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

schema JSurfaceState
  state : Vector[dimension]  // Current state Ïˆ
  energy : â„  // Current energy H(Ïˆ)
  config : JSurfaceConfig
  j_matrix : JMatrix
  hamiltonian : Hamiltonian
  time : â„â‰¥0
  
  where
    // State has correct dimension
    dim(state) = config.dimension
    
    // Energy matches Hamiltonian evaluation
    energy = hamiltonian.energy(state)
    
    // Time is non-negative
    time â‰¥ 0.0
    
    // State bounded (for numerical stability)
    âˆ€i : 1..config.dimension â€¢ |state[i]| < 10â¶
end


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Â§ 8. KERNEL LIFECYCLE                                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”€â”€[ Lifecycle Stage ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

LifecycleStage ::= embryonic | juvenile | mature | senescent

â”€â”€[ Kernel Lifecycle State ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

schema KernelLifecycle
  stage : LifecycleStage
  maturity : Fitness  // 0.0 to 1.0
  age : â„•  // Age in generations
  generation : â„•  // Generation number
  
  where
    // Age and generation non-negative
    age â‰¥ 0 âˆ§ generation â‰¥ 0
    
    // Maturity aligned with stage
    stage = embryonic â‡’ maturity < 0.3
    stage = juvenile â‡’ 0.3 â‰¤ maturity < 0.7
    stage = mature â‡’ 0.7 â‰¤ maturity â‰¤ 1.0
    stage = senescent â‡’ maturity > 1.0  // Over-mature
    
    // Age increases with generation
    age â‰¤ generation
end

â”€â”€[ Ontogenetic Kernel ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

schema OntogeneticKernel
  genome : KernelGenome
  lifecycle : KernelLifecycle
  lineage : seq String  // Parent kernel IDs
  id : String  // Unique kernel ID
  
  // Fitness components
  fitness : Fitness
  grip : Fitness      // Domain fit quality
  stability : Fitness  // Numerical stability
  efficiency : Fitness // Computational efficiency
  novelty : Fitness    // Genetic diversity
  
  where
    // ID is non-empty
    #id â‰¥ 1
    
    // Overall fitness is combination of components
    fitness = (grip + stability + efficiency + novelty) / 4.0
    
    // All fitness components in valid range
    0.0 â‰¤ grip â‰¤ 1.0 âˆ§
    0.0 â‰¤ stability â‰¤ 1.0 âˆ§
    0.0 â‰¤ efficiency â‰¤ 1.0 âˆ§
    0.0 â‰¤ novelty â‰¤ 1.0
    
    // Lineage consistency
    #lineage â‰¤ 2  // At most two parents (crossover)
    
    // Embryonic kernels have no lineage
    lifecycle.stage = embryonic â‡’ #lineage = 0
end


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Â§ 9. INVARIANTS AND GLOBAL CONSTRAINTS                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”€â”€[ A000081 Consistency ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Global invariant ensuring all system components respect A000081 structure.

invariant A000081_Alignment
  âˆ€ system : DeepTreeEchoSystem â€¢
    // Tree collection respects A000081
    (âˆ€o : dom system.trees.trees_by_order â€¢
      #(system.trees.trees_by_order(o)) = A000081(o)) âˆ§
    
    // Reservoir size is cumulative tree count
    (âˆƒn : Order â€¢ 
      system.reservoir.config.size = Î£{i : 1..n â€¢ A000081(i)}) âˆ§
    
    // Number of membranes matches A000081 value
    (âˆƒk : Order â€¢ 
      #(system.psystem.membranes) = A000081(k)) âˆ§
    
    // Growth rate is A000081 ratio
    (âˆƒn : Order â€¢ 
      system.garden.growth_rate â‰ˆ A000081(n+1) / A000081(n))
end

â”€â”€[ Energy Conservation (Symplectic Systems) ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

invariant Energy_Conservation
  âˆ€ jsurface : JSurfaceState â€¢
    jsurface.config.symplectic â‡’
      // Energy approximately conserved over time
      âˆ€tâ‚, tâ‚‚ : â„â‰¥0 â€¢
        |energy_at(jsurface, tâ‚‚) - energy_at(jsurface, tâ‚)| < Îµ
  where
    Îµ = 1e-6  // Numerical tolerance
end

â”€â”€[ Echo State Property ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

invariant Echo_State_Property
  âˆ€ reservoir : ReservoirState â€¢
    // Spectral radius < 1 ensures fading memory
    spectral_radius(reservoir.weights.W_res) < 1.0 â‡’
      // Past inputs have exponentially decaying influence
      âˆ€tâ‚ < tâ‚‚ â€¢ influence(input_at(tâ‚), state_at(tâ‚‚)) < 
                  influence(input_at(tâ‚), state_at(tâ‚)) Ã— Î»áµ—Â²â»áµ—Â¹
  where
    Î» = spectral_radius(reservoir.weights.W_res)
end

â”€â”€[ Membrane Tree Structure ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

invariant Membrane_Hierarchy
  âˆ€ psystem : PSystemConfiguration â€¢
    // Membrane hierarchy is a tree (connected, acyclic)
    is_tree(psystem.membranes) âˆ§
    
    // Unique root
    (âˆƒ! m : psystem.membranes â€¢ m.level = 0) âˆ§
    
    // All membranes reachable from root
    (âˆ€m : psystem.membranes â€¢ 
      reachable_from(psystem.root_membrane, m.id, psystem.membranes))
end

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
End of Data Model Specification
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

This specification defines the core data structures of CogPilot.jl. The next
specification file (system_state.zpp) will formalize how these components
compose into the overall system state.
