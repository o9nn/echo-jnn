messages:
  - role: system
    content: ";\n; Main Atomese guile module\n;\n; When this module is loaded from the guile prompt, it sets up all of\n; the Atomese infrastructure, including a default AtomSpace.\n;\n; To use, say this from the guile prompt:\n; (use-modules (opencog))\n;\n;\n; This should result in a utf8 locale being used!\n; See https://github.com/opencog/opencog/issues/937\n(setlocale LC_CTYPE \"\")\n(setlocale LC_NUMERIC \"C\")\n\n(define-module (opencog))\n\n; When compiling this file, before any install has been made, a call to\n; (use-modules (opencog as-config))\n; will fail because (duh) it's not installed. So, instead, we manually\n; hunt for it, and use the local build version.  This is yet another\n; hairy hack needed to be able to run unit tests without installing.\n(if (resolve-module (list 'opencog 'as-config) #:ensure #f)\n\t(use-modules (opencog as-config))\n\t(load-from-path \"opencog/as-config.scm\"))\n\n(load-extension (string-append opencog-ext-path-smob \"libsmob\") \"opencog_guile_init\")\n\n; List everything to be exported from the C++ code i.e. from libsmob,\n; as otherwise guile generates warnings about \"possibly unbound variable\"\n; when these are touched in the various scm files.\n(export\ncog-add-atomspace\ncog-arity\ncog-atom\ncog-atom?\ncog-atom-less?\ncog-atomspace\ncog-atomspace?\ncog-atomspace-clear\ncog-atomspace-cow!\ncog-atomspace-cow?\ncog-atomspace-env\ncog-atomspace-readonly?\ncog-atomspace-ro!\ncog-atomspace-rw!\ncog-atomspace-uuid\ncog-confidence\ncog-count\ncog-count-atoms\ncog-equal?\ncog-extract!\ncog-extract-recursive!\ncog-get-subtypes\ncog-get-types\ncog-handle\ncog-inc-count!\ncog-incoming-by-type\ncog-incoming-set\ncog-incoming-size\ncog-incoming-size-by-type\ncog-inc-value!\ncog-keys\ncog-keys->alist\ncog-link\ncog-link?\ncog-map-type\ncog-mean\ncog-name\ncog-new-ast\ncog-new-atom\ncog-new-atomspace\ncog-new-link\ncog-new-node\ncog-new-value\ncog-node\ncog-node?\ncog-number\ncog-outgoing-atom\ncog-outgoing-by-type\ncog-outgoing-set\ncog-set-atomspace!\ncog-set-server-mode!\ncog-set-tv!\ncog-set-value!\ncog-set-value-ref!\ncog-set-values!\ncog-subtype?\ncog-tv\ncog-tv-confidence\ncog-tv-count\ncog-tv-mean\ncog-tv-merge\ncog-tv-merge-hi-conf\ncog-type\ncog-type->int\ncog-update-value!\ncog-value\ncog-value?\ncog-value->list\ncog-value-ref\ncog-value-type\n)\n\n; Print C++ exceptions so that they are readable.\n(define (cpp-exception-printer port key args default-printer)\n\t(format port \"Atomspace C++ exception:\\n~A\\n\" args))\n\n; set-exception-printer! is exposed by ice-9/boot-9\n(set-exception-printer! 'C++-EXCEPTION cpp-exception-printer)\n\n; Create a global to hold the atomspace ... to (try to) prevent guile\n; GC from collecting it.  Unfortunately, there appears to be a GC bug\n; in guile-2.1 that causes this to be collected, anyway.  Its as if\n; guile forgets about this ... how? why? I don't get it.\n;\n; In various bad scenarios, the cogserver creates it's own atomspace,\n; before the code here runs.  We want to avoid creating a second\n; atomspace as a result. The below tries to avoid problems by simply\n; grabbing the existing atomspace, if there already is one.\n;\n; FIXME: Both of the above-described problems might no longer exist.\n; I'm not sure. The below is simple and painless, I'm leaving it for\n; now.\n\n(define-public cog-initial-as (cog-atomspace))\n(define-public my-as (cog-atomspace))\n(if (nil? cog-initial-as)\n\t(begin\n\t\t(set! cog-initial-as (cog-new-atomspace))\n\t\t; Initialize a default atomspace, just to keep things sane...\n\t\t(cog-set-atomspace! cog-initial-as)))\n\n; Renamed functions\n(define-public (cog-as ATOM) \"See cog-atomspace\" (cog-atomspace ATOM))\n(define-public (cog-extract ATOM) \"See cog-extract!\" (cog-extract! ATOM))\n(define-public (cog-extract-recursive ATOM)\n\t\"See cog-extract-recursive!\" (cog-extract-recursive! ATOM))\n(define-public (cog-remove ATOM) \"See cog-extract!\" (cog-extract! ATOM))\n\n; A very special association-list ctor.\n(define-public (alist . x) (list 'alist x))\n\n; Load core atom types.\n(include-from-path \"opencog/base/core_types.scm\")\n\n; Backwards-compat defines. I wish these were autogenerated,\n; but they are not.\n(define-public (TypeSet . x)\n\t(apply cog-new-link (cons TypeIntersectionLinkType x)))\n(define-public (TypeSetLink . x)\n\t(apply cog-new-link (cons TypeIntersectionLinkType x)))\n\n; Load other grunge too.\n; Some of these things could possibly be turned into modules ...?\n; ATTENTION: if you add a file here, then be sure to ALSO add it to\n; ../opencog/guile/SchemeSmob.cc SchemeSmob::module_init() circa line 260\n\n(include-from-path \"opencog/base/core-docs.scm\")\n(include-from-path \"opencog/base/atom-docs.scm\")\n(include-from-path \"opencog/base/utilities.scm\")\n(include-from-path \"opencog/base/atom-cache.scm\")\n(include-from-path \"opencog/base/apply.scm\")\n(include-from-path \"opencog/base/tv.scm\")\n(include-from-path \"opencog/base/types.scm\")\n(include-from-path \"opencog/base/file-utils.scm\")\n(include-from-path \"opencog/base/debug-trace.scm\")\n\n; Obsolete functions\n(define-public (cog-undefined-handle) \"obsolete function\" '())\n"
  - role: user
    content: what does our repo need next?
model: openai/o1-mini
